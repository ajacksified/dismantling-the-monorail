<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Dismantling the Monorail</title>

    <meta name="author" content="Jack Lawson <ajacksified@gmail.com>">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/serif.css" id="theme">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- If the query includes 'print-pdf', use the PDF print sheet -->
    <script>
      document.write('<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">');
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>
  <body>

    <div class="reveal">
      <div class="slides">

        <section>
          <h1>Dismantling the Monorail</h1>
          <p>Jack Lawson (<a href="https://twitter.com/ajacksified" target="_blank">@ajacksified</a>)</p>
        </section>

        <section>
          <h1>Goals</h1>
          <aside class="notes">
            It is easy to say "set your sights on a goal, and do whatever you
            can to achieve it." however, what is possible is defined by the
            level of craftsmanship placed on the steps along the way. Goals can
            be adjusted, but only if you're prepared for it. Luck favors the
            prepared. Amazon revolutionized.
          </aside>
        </section>

        <section>
          <h1>In the Beginning</h1>
          <h2>A Team Builds An App</h2>

          <aside class="notes">
            There are multiple scenarios that cause monolithic applications,
            not all of them necessarily evil. One case is when building a new
            application.
          </aside>
        </section>

        <section>
          <h2>Priority #1</h2>
          <h1>Rapid Iteration</h1>

          <aside class="notes">
            The most important thing for many new projects is to rapidly
            iterate on a product idea in order to evaluate its usefulness. The
            formation of the MVP.
          </aside>
        </section>

        <section>
          <h1>Fast Feature Development</h1>

          <aside class="notes">
            It is at this stage that the ratio of new features is greatest- the
            evolution of an application takes place through new features, much
            like cell division.
          </aside>
        </section>

        <section>
          <h1>Simple Conceptual Model</h1>

          <aside class="notes">
            To facilitate organization, it needs to be easy to communicate with
            a team while being easy to keep inside your head.
          </aside>
        </section>

        <section>
          <h1>Single MVC Application</h1>
          <h2>Layers Are Great</h2>
          <h6>That's not sarcasm</h6>

          <aside class="notes">
            MVC fits all of these things; it gives you simple, obvious buckets
            to place things. Many developers already understand the concept or
            can learn it quickly. Most web frameworks are MVC, many mobile and
            desktop apps are MV* (MVVM, etc) already.
          </aside>
        </section>

        <section>
          <img src="./img/mvc-simple.gif" />

          <aside class="notes">
            MVC apps supposedly look like this diagram; visitor goes to
            catkarma.com, the url is routed to a controller, which
            populates a view with model data and is returned. The user can then
            vote on pictures of cats.
          </aside>
        </section>

        <section>
          <h1>Optimized Communication</h1>
          <h2>Keep It All In Your Head</h2>

          <aside class="notes">
            Communication overhead is minimal for a small team, whether that
            means you or you and a dozen other people; as long as everyone
            sticks to their well-defined buckets.
          </aside>
        </section>

        <section>
          <h1>It's Easy</h1>
          <p>for example</p>
          <pre><code>rails new catkarma</code></pre>
          <p>or</p>
          <pre><code>express --sessions --css less --hogan catkarma</code></pre>
          <p>then</p>
          <pre><code>cd catkarma
git init
git add .
git commit -m 'Intial'
heroku create
git push heroku master</code></pre>

          <aside class="notes">
            You can have a datbase-connected crud app with all the ideals
            aforementioned after a few lines in a bash shell. Super easy to get
            set up with tooling and servers.
          </aside>
        </section>

        <section>
          <h2>Later On</h2>
          <h1>Shifting Priorities</h1>
          <h6>catkarma a riotious success</h6>
        </section>

        <section>
          <h2>Time is Your Enemy</h2>
          <h1>Chaos and Entropy</h1>

          <aside class="notes">
            Not everyone sticks to their well-defined buckets. Html leaks into
            controllers, SQL leaks into helpers (and directly into views), and
            the lines get a whole lot blurrier.
          </aside>
        </section>

        <section>
          <h1>A Growing <small>(Application / Team)</small> Introduces Complexity</h1>

          <aside class="notes">
            Keeping track of what features are where and who maintains what and
            which part of code depends on another gets very complicated,
            quickly.
          </aside>
        </section>

        <section>
          <h1>Higher Communication Overhead</h1>
          <h3>Meetings, Standups, &amp; <em>Coordination</em></h3>

          <aside class="notes">
            Suddenly, the communication model isn't as simple as it eas. The
            model, previously optimized for small applications and teams,
            can't fit into your head all at once anymore in a web of complexity.
          </aside>
        </section>

        <section>
          <h1>More Maintainance, Less Feature Development</h1>

          <aside class="notes">
            Because of the increased communication overhead, it becomes common
            to  do more maintainance than actual feature dev. Time is spent
            learning the way around hacks implemented long ago in dark corners.
            Bringing new devs up to speed takes longer and longer.
          </aside>
        </section>

        <section>
          <h1>Big Problems if Test Suite is Lacking</h1>

          <aside class="notes">
            Refactoring becomes a massive beast of a problem without good
            testing, which is really hard to do without stict separation of
            concerns (overuse of helpers, for example.)
          </aside>
        </section>

        <section>
          <h1>Upgrading Dependencies Becomes Hard</h1>
          <h6>Raise your hand if you've ever put off a Rails 3.2 Upgrade</h6>

          <aside class="notes">
            With an entire application written in a single mvc framework,
            upgrading portions - or the framework itself - becomes very
            difficult, as each change potentially affects everything.
          </aside>
        </section>

        <section>
          <h1>One-offs and Duplicated Code</h1>
          <h2>Specific APIs for Mobile</h2>

          <aside class="notes">
            When building a monolithic application for a single use case - such
            as the web - APIs are almost always an afterthought, because the
            app can call itself instead of requiring a well-defined API. Then
            mobile sites / app[ps step in, and one-offs are created.
          </aside>
        </section>

        <section>
          <h2>To Solve Performance</h2>
          <h1>"Throw more metal at it"</h1>

          <aside class="notes">
            There's one way to scale a monolithic app- well, two. One is to
            profile and optimize whatever you can.  The other is to throw
            more isntances of that app up on more distributed servers.
          </aside>
        </section>

        <section>
          <h1>Strained Conventions</h1>
          <h2>Shortcuts are Easy When Everything's Accessible</h2>
        </section>

        <section>
          <h1>The Easy Route is Taken When Optimizing For the Short-Term</h1>
        </section>

        <section>
          <h1>That Means Shortcuts</h1>
          <h3>Like view helpers directly calling SQL</h3>
        </section>

        <section>
          <h1>Simple MVC Conceptual Model</h1>
        </section>

        <section>
          <img src="./img/mvc-simple.gif" />
        </section>

        <section>
          <img src="./img/mvc-oh-no.gif" />
        </section>

        <section data-state="alert">
          <h1>Complex Broken MVC Model Full of Hacks</h1>
          <h4>:(</h4>
        </section>

        <section>
          <h2>You May Ask Yourself</h2>
          <h1>How Did I Get Here?</h1>
        </section>

        <section>
          <h1>Once X is Done, We Will Rebuild It All Better</h1>
        </section>

        <section>
          <h1>X Almost Never "Gets Done"</h1>
        </section>

        <section>
          <h1>Dismantling the Monorail</h1>
        </section>

        <section>
          <h1>Prioritize Long-Term Development Efficiency</h1>
        </section>

        <section>
          <h1>Have Your Cake and Eat It Too</h1>
        </section>

        <section>
          <h1>A Different Conceptual Model</h1>
          <h2>It's Still Simple</h2>
        </section>

        <section>
          <h1>Services</h1>
        </section>

        <section>
          <img src="./img/services.gif" />
        </section>

        <section>
          <h1>Not a Particularly New Idea</h1>
          <h5>You're likely familiar with "the internet", a distributed system</h5>
        </section>

        <section>
          <h1>Discrete Systems Lead To Specialization</h1>
        </section>

        <section>
          <img src="./img/services-closeup.gif" />
        </section>

        <section>
          <h1>UX is Removed From Application Logic <em>Impmlementation</em></h1>
        </section>

        <section>
          <h1>Isolated Specialization Leads to Flexibility</h1>
        </section>

        <section>
          <h1>Flexibility: Using the Right Tool for the Job</h1>
        </section>

        <section>
          <h2>Best Framework for Application Logic</h2>
          <h2>Best Framework for UX</h2>
          <h2>Best Database for Persistence</h2>
          <h6>These Are Almost Never the Same Answer</h6>
        </section>

        <section>
          <h1>Reusable APIs</h1>
          <h2>Implement Android, iOS, Google Glasses,</h2>
          <h3>Kindles, Game Consoles,</h3>
          <h4>Raspberry Pis, Desktops, Laptops,</h4>
          <h5>e-paper Wristwatches, 3-D Printers, </h5>
          <h6>Chatbots, Console Scripts, public APIs...</h6>
          <h2>With No Special Code</h2>
        </section>

        <section>
          <h2>Provided You Use</h2>
          <h1>Common Protocols</h1>
          <h2>Like JSON Over Strict REST</h2>
        </section>

        <section>
          <h1>Introduces Additional <del>Complexities</del> Opportunities</h1>
        </section>

        <section>
          <h1>Partial Failure</h1>
          <h2>Means The Entire Application Isn't Unavailable</h2>
        </section>

        <section>
          <h1>Multiple Systems at Once</h1>
          <h2>Highlights Communication Inefficiencies</h2>
        </section>

        <section>
          <h1>More Complex Ops</h1>
          <h2>Allows Scaling of Burdened Services for More Efficient Server Utilization</h2>
        </section>

        <section>
          <h1>Shared Assets</h1>
          <h2>Bundle Reusable Libraries</h2>
        </section>

        <section>
          <h1>Efficiencies From Specialization, Re-Use, and Scaling</h1>
        </section>

        <section>
          <h1>Fast Iterations</h1>
          <h2>Which Is What We Wanted Anyway</h2>
        </section>

        <section>
          <h1>Less Overhead</h1>
          <h2>More Efficiently Used Servers and Developer Time</h2>
        </section>

        <section>
          <h1>Less Frustration</h1>
          <h2>Stop Digging Through SQL Injected In View Helpers</h2>
        </section>

        <section>
          <h1>Proof</h1>
          <h2>Amazon, Netflix, many others</h2>
        </section>

        <section>
          <h1>Getting There</h1>
          <h2>Few People Are Starting from Nothing</h2>
        </section>

        <section>
          <h1>Separate Logic into Libraries</h1>
          <h2>Move Business Logic into NPM pacakages, Gems, JARs, what-have-you</h2>
        </section>

        <section>
          <h1>Draw the Line Between Models</h1>
          <h2>Eleminate Model Talking Where Possible</h2>
        </section>

        <section>
          <h1>Separate Libraries into Servers</h1>
          <h2>Define an interface (like JSON over REST)</h2>
        </section>

        <section>
          <h1>Delete Your Old Monolithic Repository</h1>
        </section>

        <section>
          <h1>Monorail Dismantled</h1>
        </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>

    <script>
    // Full list of configuration options available here:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
      controls: true,
      progress: true,
      history: true,
      center: true,

      theme: Reveal.getQueryHash().theme || 'serif',
      transition: 'linear', // default/cube/page/concave/zoom/linear/fade/none

      // Optional libraries used to extend on reveal.js
      dependencies: [
        { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
        { src: 'plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
        { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
        { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
        // { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
      ]
    });
    </script>
  </body>
</html>
